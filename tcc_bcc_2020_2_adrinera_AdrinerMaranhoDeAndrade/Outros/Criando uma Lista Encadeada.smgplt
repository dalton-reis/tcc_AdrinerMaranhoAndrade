{"id":"50e08e6b-8c9e-44b2-b356-900cbcc0e510","name":"Criando uma Lista Encadeada","description":"<p>Uma&nbsp;Lista&nbsp;Encadeada&nbsp;é&nbsp;uma&nbsp;estrutura&nbsp;de&nbsp;dados&nbsp;linear&nbsp;composta&nbsp;por&nbsp;nós&nbsp;que&nbsp;apontam&nbsp;para&nbsp;o&nbsp;seu&nbsp;próximo&nbsp;vizinho.</p><p>&nbsp;&nbsp;Para&nbsp;criar&nbsp;uma&nbsp;lista&nbsp;encadeada,&nbsp;basta&nbsp;definir&nbsp;um&nbsp;nó&nbsp;inicial&nbsp;e&nbsp;para&nbsp;cada&nbsp;nó&nbsp;existente&nbsp;salvar&nbsp;o&nbsp;seu&nbsp;sucessor.</p><p>&nbsp;&nbsp;A&nbsp;imagem&nbsp;abaixo&nbsp;ilustra&nbsp;uma&nbsp;lista&nbsp;encadeada:</p><p><br></p><p><img src=\"https://drive.google.com/u/0/uc?id=1LWCd7WTSEP8pER6dUEnAEj05ZcTTh_3t&amp;export=download\"></p><p>&nbsp;&nbsp;Performática&nbsp;para&nbsp;operações&nbsp;de&nbsp;adição&nbsp;e&nbsp;exclusão&nbsp;de&nbsp;elementos,&nbsp;a&nbsp;lista&nbsp;encadeada&nbsp;não&nbsp;se&nbsp;torna&nbsp;performática&nbsp;em&nbsp;operações&nbsp;de&nbsp;acesso&nbsp;direto&nbsp;a&nbsp;uma&nbsp;posição&nbsp;da&nbsp;lista,</p><p>&nbsp;&nbsp;pois&nbsp;precisa&nbsp;percorrer&nbsp;todos&nbsp;os&nbsp;nós&nbsp;anteriores.</p><p>&nbsp;&nbsp;Existem&nbsp;variações&nbsp;da&nbsp;lista&nbsp;encadeada,&nbsp;como&nbsp;a&nbsp;lista&nbsp;duplamente&nbsp;encadeada,&nbsp;na&nbsp;qual&nbsp;cada&nbsp;nó&nbsp;aponta&nbsp;para&nbsp;o&nbsp;seu&nbsp;sucessor&nbsp;e&nbsp;o&nbsp;seu&nbsp;antecessor.</p><p>&nbsp;&nbsp;Neste&nbsp;exercício&nbsp;trabalharemos&nbsp;apenas&nbsp;com&nbsp;a&nbsp;lista&nbsp;encadeada&nbsp;simples.</p><p>&nbsp;&nbsp;</p><p>&nbsp;&nbsp;Você&nbsp;deverá&nbsp;implementar&nbsp;o&nbsp;método&nbsp;de&nbsp;adição,&nbsp;remoção,&nbsp;obtenção&nbsp;de&nbsp;um&nbsp;elemento,&nbsp;tamanho&nbsp;da&nbsp;lista&nbsp;e&nbsp;verificação&nbsp;se&nbsp;a&nbsp;lista&nbsp;contém&nbsp;um&nbsp;determinado&nbsp;elemento.&nbsp;</p>","classContract":{"name":"ListaEncadeada","fields":[{"name":"noFinal","description":"Último nó da lista"},{"name":"noInicial","description":"Primeiro nó da lista"},{"name":"tamanho","description":"Tamanho da lista"}],"methods":[{"name":"adicionar","parameters":"elemento","description":"Adiciona um elemento na lista."},{"name":"remover","parameters":"elemento","description":"Remove um elemento da lista"},{"name":"contem","parameters":"elemento","description":"Verifica se um elemento existe na lista"},{"name":"obter","parameters":"posicao","description":"Retorna o elemento presente na posição informada"},{"name":"obterTamanho","parameters":"","description":"Retorna o tamanho da lista"}]},"scenarios":[{"id":"726a4264-232b-4a15-aa38-fd6e0da09860","name":"Adicionar","description":"Este cenário adiciona 3 elementos na lista.\n\nPara fins de testes, coloque o nome do atributo do nó que possui o valor como \"valor\" e o atributo que aponta para o próximo nó como \"proximo\". Ex.: no_1.set('valor', elemento) e no_2.set('proximo', no_1)","code":"listaEncadeada.adicionar(1);\r\nlistaEncadeada.adicionar(2);\r\nlistaEncadeada.adicionar(3);\r\n\r\nconst objects = context.getObjects();\r\nconst containers = context.getContainers();\r\nconst primitives = context.getPrimitives();\r\n\r\nassertion.assertEquals(3, objects.length, 'O número de objetos deveria ser 3.');\r\nassertion.assertEquals(0, containers.length, 'Não podem ser utilizados containers nesse problema.');\r\nassertion.assertEquals(3, listaEncadeada.obterTamanho(), 'O tamanho da lista encadeada deveria ser 3.');\r\n\r\nlet objNo = listaEncadeada.noInicial.obj;\r\nassertion.assertEquals(1, objNo['valor'], 'O primeiro elemento não é 1.');\r\nobjNo = objNo['proximo'].obj;\r\nassertion.assertEquals(2, objNo['valor'], 'O segundo elemento não é 2.');\r\nobjNo = objNo['proximo'].obj;\r\nassertion.assertEquals(3, objNo['valor'], 'O terceiro elemento não é 3.');"},{"id":"e5340e17-1d62-454b-b8d4-077a5b1f47f8","name":"Remover","description":"Este cenário realiza a inserção de 4 elementos na lista. Após isso ele remove um dos elementos, o número 30.\n\nPara fins de testes, coloque o nome do atributo do nó que possui o valor como \"valor\" e o atributo que aponta para o próximo nó como \"próximo\".","code":"listaEncadeada.adicionar(20);\r\nlistaEncadeada.adicionar(30);\r\nlistaEncadeada.adicionar(40);\r\nlistaEncadeada.adicionar(50);\r\n\r\nlistaEncadeada.remover(30);\r\n\r\nassertion.assertEquals(3, listaEncadeada.obterTamanho(), 'O tamanho da lista deveria ser 3.');\r\nlet objNo = listaEncadeada.noInicial.obj;\r\nassertion.assertEquals(20, objNo['valor'], 'O primeiro elemento não é 20.');\r\nobjNo = objNo['proximo'].obj;\r\nassertion.assertEquals(40, objNo['valor'], 'O segundo elemento não é 40.');\r\nobjNo = objNo['proximo'].obj;\r\nassertion.assertEquals(50, objNo['valor'], 'O terceiro elemento não é 50.');"},{"id":"13a990a3-4faf-4915-b991-e5dcb9d2e7c1","name":"Obter","description":"Este cenário realiza a inserção de 3 elementos na lista. Após isso ele obtém o elemento 40.","code":"listaEncadeada.adicionar(20);\r\nlistaEncadeada.adicionar(30);\r\nlistaEncadeada.adicionar(40);\r\n\r\nassertion.assertEquals(40, listaEncadeada.obter(2), 'O valor da posição 2 deveria ser 40.');"},{"id":"1cc9601d-9ce5-4e84-a97e-4cb5185e529b","name":"Contém","description":"Este cenário realiza a inserção de 2 elementos na lista. Após isso, ele verifica se a lista contém o elemento 1 e então verifica se a lista possui o elemento 3 que é inexistente. ","code":"listaEncadeada.adicionar(1);\r\nlistaEncadeada.adicionar(2);\r\n\r\nassertion.assertEquals(true, listaEncadeada.contem(1), 'A lista deveria conter o elemento 1.');\r\nassertion.assertEquals(false, listaEncadeada.contem(3), 'A lista não deveria conter o elemento 3');"}],"solution":"class ListaEncadeada {\n\n\t/**\n\t * Último nó da lista\n\t */\n\tnoFinal;\n\t/**\n\t * Primeiro nó da lista\n\t */\n\tnoInicial;\n\t/**\n\t * Tamanho da lista\n\t */\n\ttamanho;\n\n\tconstructor() {\n\t\tthis.tamanho = 0;\n\t}\n\n\t/**\n\t * Adiciona um elemento na lista\n\t */\n\tadicionar(elemento) {\n\t\tconst no = context.newObject();\n\t\tif (!this.noInicial) {\n\t\t\tthis.noInicial = no;\n\t\t}\n\t\tno.set('valor', elemento);\n\t\tif (this.noFinal) {\n\t\t\tthis.noFinal.set('proximo', no);\n\t\t}\n\t\tthis.noFinal = no;\n\t\tthis.tamanho++;\n\t}\n\t/**\n\t * Remove um elemento da lista\n\t */\n\tremover(elemento) {\n\t\tlet noAnterior = null;\n\t\tlet atual = this.noInicial;\n\t\twhile (atual) {\n\t\t\tconst valor = atual.get('valor');\n\t\t\tif (valor === elemento) {\n\t\t\t\tnoAnterior.set('proximo', atual.get('proximo'));\n\t\t\t\tatual.set('proximo', null);\n\t\t\t\tthis.tamanho--;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tnoAnterior = atual;\n\t\t\t\tatual = this.noInicial.get('proximo');\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Verifica se um elemento existe na lista\n\t */\n\tcontem(elemento) {\n\t\tlet atual = this.noInicial;\n\t\twhile (atual) {\n\t\t\tconst valor = atual.get('valor');\n\t\t\tif (valor === elemento) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tatual = atual.get('proximo');\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Retorna o elemento presente na posição informada\n\t */\n\tobter(posicao) {\n\t\tlet noAtual = this.noInicial;\n\t\tfor (let i = 0; i < posicao; i++) {\n\t\t\tnoAtual = noAtual.get('proximo');\n\t\t}\n\t\treturn noAtual.get('valor');\n\t}\n\t/**\n\t * Retorna o tamanho da lista\n\t */\n\tobterTamanho() {\n\t\treturn this.tamanho;\n\t}\n\n}"}